<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DreamStation</title>
    <link rel="stylesheet" href="stylemobile.css">
</head>
<body>
    <div id="contenu"></div>
    <div id="copied" class="hidden">Rêve copié</div>
    <div id="info" onclick="showinfo()">About</div>
    <div id="about">
        <xml>
            De quoi avez vous rêvez cette nuit ?

DreamStation est un projet d'archive de nos imaginaires inconscients, mondes vaporeux et incertains qui disparaissent souvent si ils ne sont pas saisis au moment du réveil. Sur les 10 dernières années, nous nous sommes prêtés a l'exercice, <a href="https://theodelamare.xyz/">Théo Delamare </a> et <a href="https://lbvp.org/">LBVP</a>, de garder une trace de nos rêves. En s'entrainant a noter systématiquement les rêves au moment du réveil, il devient de plus en plus facile de s'en souvenir, parfois même avec une précision étonnante. Ce site est une salle des archives toujours actualisée des mondes que nous explorons la nuit, sans même y porter attention. Toutes les histoires qui y sont écrites sont open source, et forment une base de données venant du monde du sommeil, que tout un chacun peut utiliser comme support de création, que ce soit pour de l'écriture, des productions cinématographiques, stop motion, jeux vidéo, illustration etc. 

Si vous voulez utiliser l'une de ces histoires dans vos productions, mentionnez simplement ce site, et si vous voulez ajouter votre imaginaire inconscient a cette archive, nous vous reposons la question : 

<a href="mailto:reve@alliage.gallery">De quoi avez-vous rêvez cette nuit ?</a>
        </xml>
    </div>

    <script>
            let check = false;
            (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
            
            if (check == false) {
                window.location.href = "https://dreamstation.alliage.gallery/";
            }

        function showinfo() {
            let aboutEl = document.getElementById('about');
            // console.log(aboutEl);
            var about = window.getComputedStyle(aboutEl).getPropertyValue("opacity");
            // console.log(about);
           if (about > 0) {
            aboutEl.style.opacity = 0;
            aboutEl.style.pointerEvents = "none";
            // console.log("off");   
           } else {
            aboutEl.style.opacity = 1;
            aboutEl.style.pointerEvents = "all";
            // console.log("on");   
           }
        }
    </script>

    <script type="importmap">
        {
            "imports": {
                "three": "/dreamstation/lib/three.js-master/build/three.module.js",
                "three/addons/": "/dreamstation/lib/three.js-master/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from "three";
        import { CSS3DSprite, CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    
        const objects = [];
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 10000;
    
        const renderer = new CSS3DRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
    
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.autoRotate = false;
        controls.autoRotateSpeed = .1;
        controls.enableDamping = true;
        controls.dampingFactor = .18;
        controls.enableZoom = false;
        controls.enablePan = false;
    
        document.getElementById('contenu').appendChild(renderer.domElement);
    
        window.addEventListener('resize', onWindowResize);
    
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        }
    
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            render();
        }
    
        animate();
    
        function render() {
            renderer.render(scene, camera);
        }
    
    
        // Ajout des événements pour les rêves
document.querySelectorAll('.dream').forEach(dream => {
    dream.addEventListener('click', (e) => {
        e.preventDefault();
        toggleDreamOpen(e);
    });

    // Un seul gestionnaire pour les appareils tactiles
    dream.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (!e.target.classList.contains('dream-content')) {
            toggleDreamOpen(e);
        } else {
            copyTxt(e);
        }
    });
});

// Fonction pour basculer l'état ouvert/fermé d'un rêve
function toggleDreamOpen(e) {
    e.stopPropagation(); // Empêche la propagation de l'événement pour éviter les conflits avec le basculement
    let target = e.currentTarget;
    if (target) {
        target.classList.toggle('open');
    }
}

// Fonction pour copier le texte du rêve
function copyTxt(e) {
    e.stopPropagation(); // Empêche la propagation de l'événement pour éviter les conflits avec le basculement
    let target = e.currentTarget;
    if (target) {
        let dreamContent = target.textContent;
        navigator.clipboard.writeText(dreamContent).then(
            function () {
                let copied = document.getElementById("copied");
                copied.classList.remove("hidden");
                copied.classList.add("show");
                setTimeout(function () {
                    copied.classList.remove("show");
                    copied.classList.add("hidden");
                }, 3000);
            },
            function () {
                alert("Erreur lors de la copie du rêve");
            }
        );
    }
}

    
        // Détecter si l'appareil est tactile
        const isTouchDevice = 'ontouchstart' in document.documentElement;
    
        // Ajout des événements pour les rêves
        document.querySelectorAll('.dream').forEach(dream => {
            if (isTouchDevice) {
                dream.addEventListener('touchstart', toggleDreamOpen);
                dream.addEventListener('touchstart', copyTxt);
            } else {
                dream.addEventListener('click', toggleDreamOpen);
                dream.addEventListener('click', copyTxt);
            }
        });
    
        function highlightTags(tagText) {
            const dreams = document.querySelectorAll('.dream');
            dreams.forEach(dream => {
                const tags = dream.querySelectorAll('.tag');
                tags.forEach(tag => {
                    if (tag.textContent === tagText) {
                        dream.classList.add('highlight');
                    }
                });
            });
        }
    
        function removeHighlightTags() {
            const dreams = document.querySelectorAll('.dream');
            dreams.forEach(dream => {
                dream.classList.remove('highlight');
            });
        }
    
        function afficherContenu(contenu, nomFichier, nomsFichiersTxt) {
            if (!contenu.trim()) {
                console.warn(`Le fichier ${nomFichier} est vide et ne sera pas affiché.`);
                return;
            }
    
            const divContenu = document.getElementById('contenu');
    
            const dreamDiv = document.createElement('div');
            const title = document.createElement('h1');
            const tagsContainer = document.createElement('div');
            const dreamContent = document.createElement('div');
    
            dreamDiv.classList.add('dream');
            tagsContainer.id = 'tags-container';
            dreamContent.classList.add('dream-content');
    
            const lines = contenu.split('\n');
            const tagsLine = lines.find(line => line.startsWith('Tags:'));
            const tags = tagsLine ? tagsLine.replace('Tags:', '').split(',').map(tag => tag.trim()) : [];
    
            title.textContent = decodeURIComponent(nomFichier.replace(/^.*[\\\/]/, '').split('.').slice(0, -1).join('.'));
    
            const contentLines = lines.filter(line => !line.startsWith('Tags:')).join('\n');
            dreamContent.textContent = contentLines;
    
            if (tags.length > 0) {
                tags.forEach(tag => {
                    const tagElement = document.createElement('span');
                    tagElement.textContent = tag;
                    tagElement.classList.add('tag');
                    tagElement.addEventListener('click', () => highlightTags(tag));
                    tagElement.addEventListener('touchstart', () => highlightTags(tag));
                    tagElement.addEventListener('click', removeHighlightTags);
                    tagElement.addEventListener('touchstart', removeHighlightTags);
                    tagsContainer.appendChild(tagElement);
                });
            }
    
            dreamDiv.appendChild(title);
            dreamDiv.appendChild(tagsContainer);
            dreamDiv.appendChild(dreamContent);
    
            const objectCSS = new CSS3DSprite(dreamDiv);
            objects.push(objectCSS);
            scene.add(objectCSS);
    
            const i = objects.length - 1;
            const l = nomsFichiersTxt.length;
            const phi = Math.acos(-1 + (2 * i) / l);
            const theta = Math.sqrt(l * Math.PI * 3) * phi;
    
            objectCSS.position.setFromSphericalCoords(4000, phi, theta);
        }
    
        fetch('dreams/')
            .then(response => response.text())
            .then(data => {
                const parser = new DOMParser();
                const htmlDocument = parser.parseFromString(data, 'text/html');
                const elementsAncre = htmlDocument.querySelectorAll('a');
                const nomsFichiersTxt = Array.from(elementsAncre)
                    .map(a => a.href)
                    .filter(href => href.endsWith('.txt'))
                    .map(href => `dreams/${href.split('/').pop()}`); // Ensure the correct path
                
                for (let nomFichier of nomsFichiersTxt) {
                    lireFichierTxt(nomFichier, contenu => {
                        afficherContenu(contenu, nomFichier, nomsFichiersTxt);
                    });
                }
            })
            .catch(error => console.error('Une erreur est survenue :', error));
    
        function lireFichierTxt(chemin, callback) {
            return fetch(chemin)
                .then(response => response.text())
                .then(data => {
                    if (data.trim()) {
                        callback(data);
                    } else {
                        console.warn(`Le fichier ${chemin} est vide et ne sera pas traité.`);
                    }
                })
                .catch(error => console.error('Une erreur est survenue :', error));
        }
    
        var hour = new Date().getHours();
        if (hour < 7 || hour > 18) {
            document.body.classList.add('night');
            document.body.classList.remove('day');
        } else {
            document.body.classList.add('day');
            document.body.classList.remove('night');
        }
    </script>
    
</body>
</html>
