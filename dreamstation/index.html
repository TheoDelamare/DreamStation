<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DreamStation</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="contenu"></div>
    <div id="copied" class="hidden">Rêve copié</div>
    <div id="info" onclick="showinfo()">About</div>
    <div id="about">
        <xml>
            De quoi avez vous rêvez cette nuit ?

DreamStation est un projet d'archive de nos imaginaires inconscients, mondes vaporeux et incertains qui disparaissent souvent si ils ne sont pas saisis au moment du réveil. Sur les 10 dernières années, nous nous sommes prêtés a l'exercice, <a href="https://theodelamare.xyz/">Théo Delamare </a> et <a href="https://lbvp.org/">LBVP</a>, de garder une trace de nos rêves. En s'entrainant a noter systématiquement les rêves au moment du réveil, il devient de plus en plus facile de s'en souvenir, parfois même avec une précision étonnante. Ce site est une salle des archives toujours actualisée des mondes que nous explorons la nuit, sans même y porter attention. Toutes les histoires qui y sont écrites sont open source, et forment une base de données venant du monde du sommeil, que tout un chacun peut utiliser comme support de création, que ce soit pour de l'écriture, des productions cinématographiques, stop motion, jeux vidéo, illustration etc. 

Si vous voulez utiliser l'une de ces histoires dans vos productions, mentionnez simplement ce site, et si vous voulez ajouter votre imaginaire inconscient a cette archive, nous vous reposons la question : 

<a href="mailto:reve@alliage.gallery">De quoi avez-vous rêvez cette nuit ?</a>
        </xml>
    </div>

    <script>
        function showinfo() {
            let aboutEl = document.getElementById('about');
            // console.log(aboutEl);
            var about = window.getComputedStyle(aboutEl).getPropertyValue("opacity");
            console.log(about);
           if (about > 0) {
            aboutEl.style.opacity = 0;         
            // console.log("off");   
           } else {
            aboutEl.style.opacity = 1;
            // console.log("on");   
           }
        }
    </script>

    <script type="importmap">
        {
            "imports": {
                "three": "/dreamstation/lib/three.js-master/build/three.module.js",
                "three/addons/": "/dreamstation/lib/three.js-master/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from "three";
import { CSS3DSprite, CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

const objects = [];

// Camera and controls parameters
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 7000;

const renderer = new CSS3DRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);

const controls = new OrbitControls(camera, renderer.domElement);
controls.autoRotate = false;
controls.autoRotateSpeed = .1;
controls.enableDamping = true;
controls.dampingFactor = .18;
controls.enableZoom = false;
controls.enablePan = false;

document.getElementById('contenu').appendChild(renderer.domElement);

window.addEventListener('resize', onWindowResize);

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    render();
}

function animate() {
    requestAnimationFrame(animate);
    controls.update();
    render();
}

animate();

function render() {
    renderer.render(scene, camera);
}

function copyTxt(e) {
    let target = e.target;
    while (target && !target.classList.contains('dream-content')) {
        target = target.parentNode;
    }
    if (target) {
        let dreamContent = target.textContent;
        navigator.clipboard.writeText(dreamContent).then(
            function () {
                let copied = document.getElementById("copied");
                copied.classList.remove("hidden");
                copied.classList.add("show");
                setTimeout(function () {
                    copied.classList.remove("show");
                    copied.classList.add("hidden");
                }, 3000);
            },
            function () {
                alert("Erreur lors de la copie du rêve");
            }
        );
    }
}

function highlightTags(tagText) {
    const dreams = document.querySelectorAll('.dream');
    dreams.forEach(dream => {
        const tags = dream.querySelectorAll('.tag');
        tags.forEach(tag => {
            if (tag.textContent === tagText) {
                dream.classList.add('highlight');
            }
        });
    });
}

function removeHighlightTags() {
    const dreams = document.querySelectorAll('.dream');
    dreams.forEach(dream => {
        dream.classList.remove('highlight');
    });
}

function afficherContenu(contenu, nomFichier, nomsFichiersTxt) {
    if (!contenu.trim()) {
        console.warn(`Le fichier ${nomFichier} est vide et ne sera pas affiché.`);
        return;
    }

    const divContenu = document.getElementById('contenu');

    const dreamDiv = document.createElement('div');
    const title = document.createElement('h1');
    const tagsContainer = document.createElement('div');
    const dreamContent = document.createElement('div');

    dreamDiv.classList.add('dream');
    tagsContainer.id = 'tags-container';
    dreamContent.classList.add('dream-content');

    const lines = contenu.split('\n');
    const tagsLine = lines.find(line => line.startsWith('Tags:'));
    const tags = tagsLine ? tagsLine.replace('Tags:', '').split(',').map(tag => tag.trim()) : [];

    title.textContent = decodeURIComponent(nomFichier.replace(/^.*[\\\/]/, '').split('.').slice(0, -1).join('.'));

    const contentLines = lines.filter(line => !line.startsWith('Tags:')).join('\n');
    dreamContent.textContent = contentLines;

    if (tags.length > 0) {
        tags.forEach(tag => {
            const tagElement = document.createElement('span');
            tagElement.textContent = tag;
            tagElement.classList.add('tag');
            tagElement.addEventListener('mouseover', () => highlightTags(tag));
            tagElement.addEventListener('mouseout', removeHighlightTags);
            tagsContainer.appendChild(tagElement);
        });
    }

    dreamDiv.appendChild(title);
    dreamDiv.appendChild(tagsContainer);
    dreamDiv.appendChild(dreamContent);
    dreamDiv.onclick = copyTxt;

    const objectCSS = new CSS3DSprite(dreamDiv);
    objects.push(objectCSS);
    scene.add(objectCSS);

    const i = objects.length - 1;
    const l = nomsFichiersTxt.length;
    const phi = Math.acos(-1 + (2 * i) / l);
    const theta = Math.sqrt(l * Math.PI * 3) * phi;

    objectCSS.position.setFromSphericalCoords(4000, phi, theta);
}

fetch('dreams/')
    .then(response => response.text())
    .then(data => {
        const parser = new DOMParser();
        const htmlDocument = parser.parseFromString(data, 'text/html');
        const elementsAncre = htmlDocument.querySelectorAll('a');
        const nomsFichiersTxt = Array.from(elementsAncre)
            .map(a => a.href)
            .filter(href => href.endsWith('.txt'))
            .map(href => `dreams/${href.split('/').pop()}`); // Ensure the correct path
            
            
        for (let nomFichier of nomsFichiersTxt) {
            lireFichierTxt(nomFichier, contenu => {
                afficherContenu(contenu, nomFichier, nomsFichiersTxt);
            });
        }
    })
    .catch(error => console.error('Une erreur est survenue :', error));

function lireFichierTxt(chemin, callback) {
    return fetch(chemin)
        .then(response => response.text())
        .then(data => {
            if (data.trim()) {
                callback(data);
            } else {
                console.warn(`Le fichier ${chemin} est vide et ne sera pas traité.`);
            }
        })
        .catch(error => console.error('Une erreur est survenue :', error));
}


// const interval = setInterval(function() {
    var hour = new Date().getHours();
    if ( hour < 7 || hour > 18 ) {
        document.body.classList.add('night');
        document.body.classList.remove('day');
    } else {
        document.body.classList.add('day');
        document.body.classList.remove('night');
    }
//  }, 5000);


    </script>
</body>
</html>
