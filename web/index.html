<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DreamStation</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="contenu"></div>
    <div id="copied" class="hidden">Rêve copié</div>

    <script type="importmap">
        {
            "imports": {
                "three": "/web/lib/three.js-master/build/three.module.js",
                "three/addons/": "/web/lib/three.js-master/examples/jsm/"
            }
        }
    </script>

    <script type="module">

        import * as THREE from "three";
        import { CSS3DSprite, CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';


        // while (1===1) {
        //     debugger
        // }

        const objects = [];

        // Camera and controls parameters

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
        camera.position.z = 7000;


        const renderer = new CSS3DRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        
        const controls = new OrbitControls( camera, renderer.domElement );
        controls.autoRotate = false;
        controls.autoRotateSpeed = .1;

        controls.enableDamping = true;
        controls.dampingFactor = .18;

        controls.enableZoom = false;



		document.getElementById( 'contenu' ).appendChild( renderer.domElement );

        window.addEventListener( 'resize', onWindowResize );


        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

            render();

        }


        function animate() {
            requestAnimationFrame( animate );
            controls.update();
            render();
            // controls.update();
        }

        animate()
        function render() {
            renderer.render( scene, camera );
        }


        function copyTxt(e) {
            let dream = e.target.textContent;
            navigator.clipboard.writeText(dream).then(
                function () {
                    let copied = document.getElementById("copied");
                    console.log(copied);
                    copied.classList.remove("hidden");
                    copied.classList.add("show");
                },
                function () {
                    alert("שגיאה בקריאת חלום")
                },
                );
        }


        function afficherContenu(contenu, nomFichier, nomsFichiersTxt) {
            const divContenu = document.getElementById('contenu');

            const title = document.createElement('h1');
            const newParagraph = document.createElement('p');
            
            title.textContent = nomFichier.replace(/^.*[\\\/]/, '').split('.').slice(0, -1).join('.');

            newParagraph.textContent = contenu;
            newParagraph.onclick = copyTxt;
            
            newParagraph.insertBefore(title, newParagraph.firstChild);
            const objectCSS = new CSS3DSprite( newParagraph );
            objects.push( objectCSS );
            scene.add( objectCSS );

            const vector = new THREE.Vector3();

            const i = objects.length - 1;
            const l = nomsFichiersTxt.length;
            const phi = Math.acos( - 1 + ( 2 * i ) / l );
            // const phi = Math.acos( - 1 + ( 2 * i ) / l ) - .5;
            const theta = Math.sqrt( l * Math.PI * 3 ) * phi ;

            objectCSS.position.setFromSphericalCoords( 4000, phi, theta );
            // vector.copy( object.position ).multiplyScalar( 2 );
            // object.lookAt( vector );


        }

        // Récupération de la liste des fichiers .txt dans le sous-dossier
        fetch('dreams/')
            .then(response => response.text())
            .then(data => {
                // Traitement de la réponse pour obtenir une liste de noms de fichiers
                const parser = new DOMParser();
                const htmlDocument = parser.parseFromString(data, 'text/html');
                const elementsAncre = htmlDocument.querySelectorAll('a');
                const nomsFichiersTxt = Array.from(elementsAncre)
                    .map(a => a.href)
                    .filter(href => href.endsWith('.txt'));

                // Pour chaque fichier .txt, lire et afficher le contenu
                for(let nomFichier of nomsFichiersTxt) {
                    lireFichierTxt(nomFichier, contenu => {
                        afficherContenu(contenu, nomFichier, nomsFichiersTxt);
                    });
                }
            })
            .catch(error => console.error('Une erreur est survenue :', error));

            
        function lireFichierTxt(chemin, callback) {
            return fetch(chemin)
                .then(response => response.text())
                .then(data => callback(data))
                .catch(error => console.error('Une erreur est survenue :', error));
        }
        // TODO :
        // tags in dreams
        // highligt corresponding dreams when hover

    </script>
</body>
</html>